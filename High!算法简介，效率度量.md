# High!算法简介，效率度量


## 算法的定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。


## 算法的特性
输入、输出、有穷性、确定性和可行性。

## 算法的设计要求
正确性、可读性、健壮性、高效率和低存储量需求。


##算法效率的度量

```
事后统计法：
此方法利用计时器对不同的算法运行时间进行比较，而大多数事情事后再去考虑一些结果，总会显得那么的不负责任。故此方法缺陷众多——不科学
、不准确。

事前统计法
那么，一个用高级程序语言编写的程序在计算机上运行所消耗的时间取决于一下因素：
1. 算法采用的策略、方法。
2. 编译产生的代码质量。（这个往往不是编码者可以控制的:D）
3. 问题的输入规模。
4. 机器执行指令的速度。
```

>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。



###时间复杂度
>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度。

```
算法的时间复杂度，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复
杂度，简称为时间复杂度。其中。f(n)是问题规模n的某个函数。
```

**大写O()来体现时间复杂度的记法，就是“大O记法”。**三种算法时间复杂度渐进增长关系，分别为O(n)线性阶,O(1)常数阶,O($n^2$)平方阶。

**推导大O阶：**

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。

>得到的结果就是大O阶。

####常数阶
顺序结构的时间复杂度（不包含循环结构），无论执行次数n多大，这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。

```
注意：不管这个常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字，这是初学者常常犯的错误。
```

对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。

####线性阶
**我们分析算法的复杂度，关键就是要分析循环结构的运行情况。**

对于一个普通的for循环，它的循环的时间复杂度为O(n),因为循环体中的代码要执行n次,如下：
```c
int i;
for(i = 0; i < n; i++)
{
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```

####对数阶
```c
int count = 1;
while(count < n)
{
    count = count * 2;
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```

count每次乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会推出循环。由$2^x=n$得到$x=log_2n$。所以这个循环的时间复杂度是$O(log_n)$。

####平方阶
```c
int i, j;
for (i = 0; i < n; i++)
{
    for ( j = 0; j < m; j++)
    {
         /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```

总结得出，如果n=m,时间复杂度为O($n^2$);如果n!=m,时间复杂度为O(n*m)。

>思考,下面这个循环嵌套的时间复杂度

```c
int i, j;
for (i = 0; i < n; i++)
{
    for ( j = i; j < n; j++)
    {
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```


由数学的数列知识，可得总的执行次数为：

$$ n + (n - 1) + (n - 2) + ... + 1 = \frac{n(n+1)}2 = \frac{n^2}2 + \frac n2$$

然后，使用大O推导法分析：
<br>第一步，没有加法常数不予考虑；
<br>第二步，只保留最高阶项，因此保留$ \frac{n^2}2 $；
<br>第三步，去除这个项相乘的常数，也就是去除$ \frac12 $，最终这段代码的时间复杂度为$ O(n^2) $。


>再思考，这一段代码的时间复杂度。

```c
void function(int count)
{
    int j;
    for(j = 0; j < count ; j++)
    {
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}

int main()
{
    int n;                     
    scanf("%d", &n);           
    n++;                         /* 执行次数为1 */
    function(n);                 /* 执行次数为n */
    int i,j;
    for(i = 0; i < n; i++)       /* 执行次数为n^2 */
    {
        function(n);
    }
    for(i = 0; i < n; i++)       /* 执行次数为n(n+1)/2 */
    {
        for(j = i; j < n; j++)  
        {
            /* 时间复杂度为O(1)的程序步骤序列 */
        }
    }
}
```

分析得出它的执行次数：                 
$$ f(n) = 1 + n + n^2 + \frac{n(n+1)}2 =\frac{3n^2}2 + \frac{3n}2 + 1 $$
那么，根据大$ O $推导法，最终这段代码的时间复杂度也是$ O(n^2) $。

###常见的时间复杂度
| 执行次数 | 函数阶 | 非正式术语 |
|----------|----------|----------|
| 12 | $ O(1) $ | 常数阶 |
| 2n+3 | $ O(n) $ | 线性阶 |
| $ 3n^2+2n+1 $ | $ O(n^2) $ | 平方阶 |
| $ 5log_2n+20 $ | $ O(logn) $ | 对数阶 |
| $ 2n+3nlog_2n+19 $ | $ O(nlogn) $ | $ nlogn $阶 |
| $ 6n^3+2n^2+3n+4 $ | $ O(n^3) $ | 立方阶 |
| $ 2^n $ | $ O(2^n) $ | 指数阶 |

常用的时间复杂度所耗费的时间从小到大依次是：
$$ O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n) $$

##算法空间复杂度
算法空间复杂度计算公式：$ S(n)=O(f(n)) $，其中，n为问题的规模，$ f(n) $为关于n所占储存空间的函数。

若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。

通常，都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。





