# High！线性表:D
> 线性表(List):零个或多个数据元素的有限序列。

* 元素之间是有顺序的。
* 线性表强调是有限的。

若将线性表记为：$ (a_1,a_2,...,a_{i-1},a_i,a_{i+1},...,a_n) $,则$ a_{i-1} $是$ a_i $的直接前驱元素，$ a_{i+1} $是$ a_i $的直接后继元素。如图：

![](resource/img/线性表1.png)

__线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。____称i为数据元素__$ a_i $ __在线性表中的位序 __ 。


##线性表的类型定义
```
ADT 线性表（List）
Data
    线性表的数据对象集合为{a1,a2,...,an},每个元素的类型均为DataTyp(一致)。
    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素。
    除了最后一个元素an外，每一个元素有且只有一个后置元素。
    数据元素之间的关系是一对一的关系。
Operation
    InitList(*L):初始化操作，建立一个空的线性表L。
    ListEmpty(L):若线性表为空，返回true，否则返回false。
    ClearList(*L):将线性表清空。
    GetElem(L,i,*e):将线性表L中 的第i个位置元素值返回给e。
    LocateElem(L,e):在线性表中查找与给定值e相 等的元素,如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。
    ListInsert(*L,i,e):在线性表L中的第i个位置，插入新元素e。
    ListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值。
```

>如果需要修改参数数据，则需要传递指向这个参数的指针；如果不需要修改参数数据，可以直接传递这个参数。

##线性表的存储顺序

###1. 顺序存储结构方式

#### 概念：
用一段地址连续的存储单元依次存储线性表的数据元素。

#### 线性表的顺序存储的结构代码：

```c
/* 存储空间初始分配量 */
#define MAXSIZE 20
/* ElemType类型根据实际情况而定，这里假设为int */
typedef int ElemType;
typedef struct SqList
{
    /* 数组存储数据元素，最大值为MAXSIZE */
    ElemType data[MAXSIZE];
    /* 线性表当前长度 */
    int length;
};
```

#### 数组长度与线性表长度区别
* 数组的长度是存放线性表的存储空间的大小，存储分配后这个量是不变的，线性表的长度是线性表中元素个数，随着线性表插入删除操作的进行，这个量是变化的。
* 任意时刻，线性性表的长度应该小于等于数组的长度。

#### 地址计算
>线性表的起始下标是1，于是线性表的第i个元素是要存储在数组下标为i-1的位置。

假设每个顺序元素占c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足以下关系（LOC表示获得存储位置的函数）：
$$ LOC(a_{i+1})=LOC(a_i)+c $$
$$ LOC(a_i)=LOC(a_1)+(i-1)*c  $$

如图(注意理解图中数组与线性表的两者下标对应关系总是相差1；和对LOC公式的理解):

![](resource/img/线性表顺序结构.png)

考虑它的时间复杂度，它的存取时间性能为$ O(1) $__。通常把具有这一特点的存储结构称为随机存取结构。__

#### 代码描述之顺序存储结构的插入与删除

##### 获得元素操作
实现GetElem操作，即将线性表L中的第i个位置元素值返回，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。
```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status;
/* Status是函数的类型，其值是函数结果状态代码，如OK等 */
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(SqList L, int i, ElemType *e)
{
    if(L.length == 0 || i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i-1];
    return OK;
}
```

##### 插入操作
插入算法的思路：

* 如果插入位置不合理，抛出异常；
* 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
* 从最后一个元素开始向前遍历到要插入数据的第i个位置，分别都将他们向后移动一个位置。
* 将要插入的元素放到i处，并且修改表长增加1。

实现代码：
```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(SqList *L, int i, ElemType e)
{
    int k;
    /* 顺序线性表已经满 */
    if(L->length == MAXSIZE)
        return ERROR;
    /* 当i不在范围内时,当i = L->length + 1时代表在末尾插入，这点容易疏漏 */
    if(i < 1 || i > L->length + 1)
        return ERROR;
    if(i <= L->length)
    {
        /*将要插入位置后所有数据元素向后移动一位 */
        for(k = L->length - 1; k >= i-1; k--)
            L->data[k+1] = L->data[k];
    }
    L->data[i-1] = e; /* 将新元素插入 */
    L->length++;     
    return OK;
}
```

##### 删除操作
删除算法的思路：

* 如果删除位置不合理，抛出异常；
* 取出删除元素；
* 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置。
* 最后，表长减1。

实现代码：
```c
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
Status ListDelete(SqList *L, int i, ElemType *e)
{
    int k;
    /* 线性表为空 */
    if(L->length == 0)
        return ERROR;
    /* 判断删除位置是否合法 */
    if(i > L->length)
        return ERROR;
    /* 如果删除不是最后位置，需将删除位置后继元素前移 */
    if(i < L->length)
    {
        for(k = i; k < L->length; k++)
        L->data[k + 1] = L->data[k];
    }
    L->length--;
    return OK;
}
```




#### 线性表顺序存储结构的优缺点


| 优点 | 缺点 |
|------|------|
|1. 可以快速地存取表中任一位置的元素。<br>2. 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。|1. 插入和删除操作需要移动大量元素。<br>2. 当线性表长度变化较大时，难以确定存储空间的容量。<br>3. 造成存储空间的“碎片”。|

分析它的时间复杂度：

* 如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为O(1)，因为不需要移动元素。
* 如果元素要插入到第一个位置或者删除第一个元素，就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为O(n)。
* 至于平均的情况，由于元素插入到第i个位置，或删除第i个元素，需要移动n-i个元素。根据概率原理，每个位置插入或删除元素的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等（这个移动次数是指中间那个元素移动到首部或者尾部），为(n-1)/2。
* __综合推导，平均时间复杂度还是O(n)。__

---

###2.线性表的链式存储结构
#### 概念
* 存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域，有图：

![](resource/img/线性表链式结构_结点结构.png)

* 指针域中存储的信息叫做指针或链。这两部分组成数据元素ai的存储映像，称为结点(Node)。
* **单链表：** n个结点（$ a_i $的存储映像）链接成一个链表，即为线性表$ (a_1,a_2,...,a_n) $的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以称作单链表。
* 线性链表的最后一个结点指针为“空”（用NULL或'^'表示），有图：

![](resource/img/线性表链式结构_末尾结点.png)

#### 头指针与头节点
**头指针：** 链表中第一个结点的存储位置叫做**头指针**，整个链表的存取是从头指针开始进行。

**头节点：** 为了方便对链表进行操作，会在单链表的第一个节点前附设一个结点，称为头节点。有了头节点，对链表第一个元素的操作就和之后的元素一样了，不必再专门为第一个元素编写函数了，大大方便了很多。头节点的数据域可以不存储任何信息。也可以存储如线性表的长度等附加信息，__头节点的指针域存储指向第一个结点的指针。__
 
###### 两者的异同：

| 头指针 | 头节点 |
| ------ | ------ |
| 头节点是指链表指向第一个结点<br>的指针,若链表有头结点，则是指<br>向头节点的指针| 头节点是为了操作的统一和方便<br>而设立的,放在第一元素的结点之<br>前,其数据域一般无意义（也可存<br>放链表的长度）|
| 头指针具有标识作用，所以常用<br>头指针冠以链表的名字 | 有了头节点,对在第一元素结点前<br>插入结点和删除第一结点，其操作<br>与其他结点就一致了 |
| 无论链表是否为空，头指针均不<br>为空。头指针是链表的必要元素 | 头结点不一定是链表必须要素 |

若线性表为空表，则头节点的指针域为空，上图：

![](resource/img/线性表链式结构_头节点.PNG)

### 线性表链式存储结构的存储示意图

![](resource/img/线性表链式结构_存储示意图1.PNG)

PS:若存在头节点，则为：

![](resource/img/线性表链式结构_存储示意图2.PNG)


### 线性表链式存储结构代码描述

链式存储到结构描述：
```c

```





















